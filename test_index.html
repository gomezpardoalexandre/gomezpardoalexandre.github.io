<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
        <title>Gomez Pardo Alexandre</title>
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
		<style>
			body { margin: 0; 
                background-color: #ffffff;
            }
			canvas { display: block;
                background-color: #ffffff;
           }
         
		</style>
    </head>


<body>

    <div id="app"></div>

    <script type="module" src="src/index.js"></script>
 <!--- <script type="module">
            import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js';

            const easeOutSine = (t, b, c, d) => {
  return c * Math.sin((t / d) * (Math.PI / 2)) + b;
};

const easeOutQuad = (t, b, c, d) => {
  t /= d;
  return -c * t * (t - 2) + b;
};

                    class TouchTexture {
                    constructor(parent) {
                        this.size = 64;
                        this.width = window.innerWidth;
                        this.height = window.innerHeight;
                        this.width = this.height = this.size;

                        this.maxAge = 64;
                        this.radius = 0.1 * this.size;
                        // this.radius = 0.15 * 1000;

                        this.speed = 1 / this.maxAge;
                        // this.speed = 0.01;

                        this.trail = [];
                        this.last = null;

                        this.initTexture();
                    }

                    initTexture() {
                        this.canvas = document.createElement("canvas");
                        this.canvas.width = this.width;
                        this.canvas.height = this.height;
                        this.ctx = this.canvas.getContext("2d");
                        this.ctx.fillStyle = "black";
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                        this.texture = new THREE.Texture(this.canvas);
                        this.canvas.id = "touchTexture";
                        // this.canvas.style.width = this.canvas.style.height = `${
                        //   this.canvas.width
                        // }px`;
                    }
                    update(delta) {
                        this.clear();
                        let speed = this.speed;
                        this.trail.forEach((point, i) => {
                        let f = point.force * speed * (1 - point.age / this.maxAge);
                        let x = point.x;
                        let y = point.y;

                        point.x += point.vx * f;
                        point.y += point.vy * f;
                        point.age++;
                        if (point.age > this.maxAge) {
                            this.trail.splice(i, 1);
                        }
                        });

                        this.trail.forEach((point, i) => {
                        this.drawPoint(point);
                        });
                        // this.drawPoints();

                        // this.ctx.fillStyle = "rgba(255,0,0,0.5)";
                        // this.ctx.fillRect(0, 0, 200, 200);
                        // this.ctx.fillStyle = "rgba(0,255,0,0.5)";
                        // this.ctx.fillRect(50, 0, 200, 200);
                        // this.test();
                        this.texture.needsUpdate = true;
                    }
                    clear() {
                        this.ctx.fillStyle = "black";
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                    addTouch(point) {
                        let force = 0;
                        let vx = 0;
                        let vy = 0;
                        const last = this.last;
                        if (last) {
                        const dx = point.x - last.x;
                        const dy = point.y - last.y;
                        if (dx === 0 && dy === 0) return;
                        const dd = dx * dx + dy * dy;
                        let d = Math.sqrt(dd);
                        vx = dx / d;
                        vy = dy / d;

                        force = Math.min(dd * 10000, 1);
                        // force = Math.sqrt(dd)* 50.;
                        // force = 1;
                        }
                        this.last = {
                        x: point.x,
                        y: point.y
                        };
                        this.trail.push({ x: point.x, y: point.y, age: 0, force, vx, vy });
                    }
                    drawPoint(point) {
                        const ctx = this.ctx;
                        const pos = {
                        x: point.x * this.width,
                        y: (1 - point.y) * this.height
                        };

                        let intensity = 1;

                        if (point.age < this.maxAge * 0.3) {
                        intensity = easeOutSine(point.age / (this.maxAge * 0.3), 0, 1, 1);
                        } else {
                        intensity = easeOutQuad(
                            1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7),
                            0,
                            1,
                            1
                        );
                        }
                        intensity *= point.force;

                        const radius = this.radius;
                        let color = `${((point.vx + 1) / 2) * 255}, ${((point.vy + 1) / 2) *
                        255}, ${intensity * 255}`;

                        let offset = this.size * 5;
                        ctx.shadowOffsetX = offset; // (default 0)
                        ctx.shadowOffsetY = offset; // (default 0)
                        ctx.shadowBlur = radius * 1; // (default 0)
                        ctx.shadowColor = `rgba(${color},${0.2 * intensity})`; // (default transparent black)

                        this.ctx.beginPath();
                        this.ctx.fillStyle = "rgba(255,0,0,1)";
                        this.ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    }
                
            class WaterTexture{
                constructor(options) {
                    this.size = 64;
                    this.radius = this.size * 0.1;
                    this.width = this.height = this.size;
                    if (options.debug) {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.radius = this.width * 0.05;
                    this.points =[];
                    this.maxAge = 64;  
                    this.last = null;     
                    }
                    
                    this.initTexture();
                    if(options.debug) document.body.append(this.canvas);
                }
                    // Initialize our canvas
                initTexture() {
                    this.canvas = document.createElement("canvas");
                    this.canvas.id = "WaterTexture";
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                    this.ctx = this.canvas.getContext("2d");
                    this.clear();
                    this.texture = new THREE.Texture(this.canvas);
                    
                }
                clear() {
                    this.ctx.fillStyle = "black";
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                update(){
                    this.clear();
                    let agePart = 1. / this.maxAge;
                    this.points.forEach((point,i) => {
                        let slowAsOlder = (1.- point.age / this.maxAge)
                        let force = point.force * agePart * slowAsOlder;
                        point.x += point.vx * force;
                        point.y += point.vy * force;
                        point.age += 1;
                        if(point.age > this.maxAge){
                            this.points.splice(i, 1);
                        }
                    })
                    this.points.forEach(point => {
                        this.drawPoint(point);
                    });
                    this.texture.needsUpdate = true;
                }
                
                drawPoint(point) {
                // Convert normalized position into canvas coordinates
                // Convert normalized position into canvas coordinates
                let pos = {
                x: point.x * this.width,
                y: point.y * this.height
                };
                const radius = this.radius;
                const ctx = this.ctx;

                let intensity = 1;
                if (point.age < this.maxAge * 0.3) {
                intensity = easeOutSine(point.age / (this.maxAge * 0.3), 0, 1, 1);
                } else {
                intensity = easeOutQuad(
                    1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7),
                    0,
                    1,
                    1
                );
                }
                intensity *= point.force;

                let red = ((point.vx + 1) / 2) * 255;
                let green = ((point.vy + 1) / 2) * 255;
                // B = Unit vector
                let blue = intensity * 255;
                let color = `${red}, ${green}, ${blue}`;

                let offset = this.width * 5;
                // 1. Give the shadow a high offset.
                ctx.shadowOffsetX = offset;
                ctx.shadowOffsetY = offset;
                ctx.shadowBlur = radius * 1;
                ctx.shadowColor = `rgba(${color},${0.2 * intensity})`;

                this.ctx.beginPath();
                this.ctx.fillStyle = "rgba(255,0,0,1)";
                // 2. Move the circle to the other direction of the offset
                this.ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);
                this.ctx.fill();
            }
            addPoint(point) {
                let force = 0;
                let vx = 0;
                let vy = 0;
                const last = this.last;
                if(last){
                    const relativeX = point.x - last.x;
                    const relativeY = point.y - last.y;
                    // Distance formula
                    const distanceSquared = relativeX * relativeX + relativeY * relativeY;
                    const distance = Math.sqrt(distanceSquared);
                    // Calculate Unit Vector
                    vx = relativeX / distance;
                    vy = relativeY / distance;
                    
                    force = Math.min(distanceSquared * 10000,1.);
                }
                
                this.last = {
                    x: point.x,
                    y: point.y
                }
                this.points.push({ x: point.x, y: point.y, age: 0, force, vx, vy });
            }
            }

            class App{
                constructor(){
                    this.waterTexture = new WaterTexture({ debug: true });
                    
                    this.renderer = new THREE.WebGLRenderer({
                    antialias: false
                    });
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    document.body.append(this.renderer.domElement);
                    
                    this.camera = new THREE.PerspectiveCamera(
                    45,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    10000
                    );
                    this.tick = this.tick.bind(this);
                    this.onMouseMove = this.onMouseMove.bind(this);
                    this.camera.position.z = 50;
                    
                    this.touchTexture = new TouchTexture();
                    
                   
                    
                    this.init();
                
                }
                addPlane(){
                    let geometry = new THREE.PlaneBufferGeometry(5,5,1,1);
                    let material = new THREE.MeshNormalMaterial();
                    let mesh = new THREE.Mesh(geometry, material);
                    
                    window.addEventListener("mousemove", this.onMouseMove);
                    this.scene.add(mesh);
                }
                init(){
                    this.addPlane(); 
                    this.tick();
                }
                render(){
                    this.renderer.render(this.scene, this.camera);
                }
                tick(){
                    this.render();
                    this.waterTexture.update();
                    requrestAnimationFrame(this.tick);
                }
            }
            const myApp = new App();


    </script>-->
</body>

</html>